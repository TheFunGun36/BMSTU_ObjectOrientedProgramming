# Шаблоны проектирования

## Holder (держатель, хранитель)

Проблема:

```cpp
{
    A* ptr = new A;
    ptr->f(); // создаёт исключения
    delete a; // в исключительной ситуации не удаляется
}
```

Решение:

```cpp
template <typename T>
class Holder {
    T *ptr;
public:
    Holder() { ptr = new T; }
    ~Holder() { if (ptr) delete ptr; }
    T* operator->() { return ptr; }
    T& operator*() { return *ptr; }
    operator bool() { return ptr != nullptr; }
    Holder(const Holder<T> &) = delete;
    Holder<T> &operator=(const Holder<T> &) = delete;
};
```

Теперь можно:

```cpp
{
    Holder<A> h(new A);
    h->f();
}
```

Память будет освобождаться автоматически. Возникает проблема при множественном владении указателем. Решается небольшими модификациями исходного класса, догадаться до которых несложно. В C++ реализованы следующим образом:

- `unique_ptr<Type>` - указатель существует в единственном экземпляре

- `shared_ptr<Type>` - указатель удаляется последним освободившим

- `weak_ptr<Type>` - использует уже существующий указатель, не владеет им. Создаётся от уже существующего указателя

| memory      | unique_ptr                  | shared_ptr                      | weak_ptr                          |
|:-----------:|:---------------------------:|:-------------------------------:|:---------------------------------:|
| владение    | строгое                     | совместное                      | слабое                            |
| операторы   | `*, ->, bool, []`           | `*, ->, bool, []`               | -                                 |
| копирование | нельзя                      | можно                           | можно                             |
| методы      | `get, release, reset, swap` | `get, reset, use_count, unique` | `use_count, expired, reset, lock` |

## Iterator

Итератор - специальная структура данных, привязанная к другой, "перечисляемой" структуре данных. Итератор, по своей сути, является указателем на текущий элемент. Необходим для того, чтобы не привязываться к данным, и унифицировать интерфейс взаимодействия с ними.

## 
